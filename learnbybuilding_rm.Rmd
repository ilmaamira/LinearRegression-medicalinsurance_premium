---
title: "Predict Your Medical Insurance Premium"
author: "Ilma Amira Rahmayanti"
date: "2022-05-23"
output:
  html_document:
    df_print: paged
    highlight: breezedark
    theme: journal
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<style type="text/css">
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkRed;
}
h2 { /* Header 2 */
  font-size: 28px;
  color: DarkRed;
}
h3 { /* Header 3 */
  font-size: 24px;
  color: DarkRed;
}
h4 { /* Header 4 */
  font-size: 20px;
  color: Black;
}
h5 { /* Header 5 */
  font-size: 20px;
  color: DarkRed;
}
body{ /* Normal  */
      font-size: 16px;
  }
</style>

## An Implementation of Linear Regression in Insurance Industry {.unlisted .unnumbered}
<br>
```{r, echo=FALSE, out.width='45%', fig.align='center'}
knitr::include_graphics("assets/medical.jpg")
```

### 1. Preface {.tabset .tabset-fade .tabset-pills}

#### 1.1 Background

It is natural that we all will do whatever it takes to protect ourselves, our family, and our loved ones, especially in matters related to health. However, it is not uncommon that we also want to do it at a cost we can afford - fits within our financial budget.

A recent study from industry groups LIMRA and Life Happens found out that 102 million uninsured and underinsured Americans (which are 40% of the countryâ€™s adult population) believe that they need to purchase medical insurance or invest in more coverage. However, more than one in three put off buying coverage because they often think it costs more than it does. That matter can put their family at risk if they get in accident unexpectedly.

Many people believe medical insurance is out of reach financially, often because they donâ€™t know how medical insurance factors impact pricing. Yet medical insurance is one of the most affordable parts of a strong financial plan. Since cost misunderstandings are a main reason why people donâ€™t buy, letâ€™s consider what really goes into the premium price of medical insurance.

In this project, we will focus on linear regression to investigate how the predictors influence the medical insurance premium price. In the future, you can also use the final equation/model to estimate the price of your insurance premium by putting in several conditions. So, without further ado, check this out~ ðŸ˜‰

âš ï¸ **Disclaimer**: 

Predictions generated by the final equation/model are estimates only. In fact, there are another conditions that can affect the accuracy of predictions (such as year, exchange rate, inflation, insurance company rules, etc.). 

> **My opinion**: just focus on how each variable affects the premium price (whether the predictor variable give a positive effect/increasing premium price or give negative effect/lowering premium price)

#### 1.2 About the Dataset

This project uses the dataset taken from [kaggle](https://www.kaggle.com/code/prasadchaskar/medical-insurance-premium-prediction/data?select=Medicalpremium.csv). This dataset contains information from 986 clients of an insurance company, including information regarding yearly premium prices.

The columns in the dataset consist of:

- `Age` : the age of the client (in years)
- `Diabetes` : whether the client has abnormal bloodsugar levels (0 = No, 1 = Yes)
- `BloodPressureProblems` : whether the client has abnormal blood pressure levels (0 = No, 1 = Yes)
- `AnyTransplants` : whether the client has any major organ transplants (0 = No, 1 = Yes)
- `AnyChronicDiseases` : whether the client suffers from chronic ailments like asthma, etc. (0 = No, 1 = Yes)
- `Height` : the height of the client (in centimeter)
- `Weight` : the weight of the client (in kilogram)
- `KnownAllergies` : whether the client has any known allergies (0 = No, 1 = Yes)
- `HistoryOfCancerInFamily` : whether any blood relative of the client has had any form of cancer (0 = No, 1 = Yes)
- `NumberOfMajorSurgeries` : the number of major surgeries that the client has had
- `PremiumPrice` : yearly medical insurance premium price (in Indian Rupees/INR(â‚¹) Currency)

### 2. Dependencies 

Load all the libraries needed to work on this project:

```{r message = FALSE}
# load libraries
library(dplyr) # for data transformation
library(DT) # to make a table in rmarkdown
library(ggplot2) # to make visualization
library(GGally) # for EDA or correlation check
library(performance) # for model comparison and assumption check
library(MLmetrics) # to calculate the error value
```

### 3. Read Data

```{r}
# read data
insurance <- read.csv("data_input/insurance.csv", header=T, na.strings=c(""))
```

```{r echo=FALSE}
datatable(insurance, extensions = 'FixedColumns', fillContainer = T)
```

Based on the table above, we can see that our dataset consists of 11 variables. 

### 4. Data Cleansing

First of all, we have to check the structure of our dataset - whether the data types are correct or not.

```{r}
# check data structure
str(insurance)
```

There seems to be some mismatched data types. So, before we proceed to the next step, we must change these data types.

```{r}
# change data type
insurance[,c("Diabetes","BloodPressureProblems","AnyTransplants","AnyChronicDiseases",
  "KnownAllergies","HistoryOfCancerInFamily")] <-
  lapply(insurance[,c("Diabetes","BloodPressureProblems",
  "AnyTransplants","AnyChronicDiseases","KnownAllergies",
  "HistoryOfCancerInFamily")], as.factor)
```

We can also add a new column containing BMI (Body Mass Index) -  a medical screening tool that measures the ratio of height to weight to estimate the amount of body fat.

```{r}
# make BMI column
insurance <- insurance %>% 
  mutate(BMI = Weight/((Height/100)^2))
```

Check the data structure again for one last time before we move on to the next step.

```{r}
# take a glimpse of the data
glimpse(insurance)
```

Also check if there are any missing values.

```{r}
# check missing values
colSums(is.na(insurance))
```

It looks like that the data types are already correct. Furthermore, there are no missing values in our dataset, hence, we can proceed to the next phase.

### 5. Target Variable and Predictor Variable

- Target variable: `PremiumPrice`
- Predictor variables: `Age`, `Diabetes`, `BloodPressureProblems`, `AnyTransplants`, `AnyChronicDiseases`, `Height`, `Weight`, `KnownAllergies`, `HistoryOfCancerInFamily`, `NumberOfMajorSurgeries`, `BMI`

### 6. Feature Selection

We know that the `BMI` is the result of a calculation between `Height` and `Weight`. So, by intuition, we can remove `Height` and `Weight` from the predictor variables as their values are already represented by the `BMI` column.

```{r}
# remove Height and Weight columns
insurance_clean <- insurance %>% 
  select(-c("Height","Weight"))
```

### 7. Exploratory Data Analysis (EDA)

Check whether our dataset has outliers.

```{r fig.align='center'}
# check outliers
ggplot(data = insurance_clean, mapping = aes(x = "", y = PremiumPrice)) +
  geom_boxplot(fill = "#C2981D", color = "#415C23") +
  xlab("") +
  ylab("Medical Insurance Premium Price")
```

It can be seen that our dataset has some outliers (although it's not too much). Let's see the value of these outliers.

```{r}
# find out the value of the outliers
boxplot.stats(insurance_clean$PremiumPrice)$out
```
So, we can conclude that the premium prices become outliers if the values are more than 39000. 

But for now, let's just ignore these outliers, and we'll talk about them later when tuning the model.

After finding out about outliers, we continue by checking the correlation between variables.

```{r warning = FALSE}
# check correlation using heatmap
ggcorr(insurance_clean, hjust = 1, layout.exp = 1, label = TRUE)
```

```{r fig.align='center'}
# check correlation using correlation test
# a starred value means that there is a significant correlation
ggduo(insurance_clean, 
      c("Age","NumberOfMajorSurgeries","BMI"), "PremiumPrice", 
      types = list(continuous = "cor"))
```

```{r fig.align='center'}
# check correlation between categoric variable and target variable
ggduo(insurance_clean, 
      c("Diabetes","BloodPressureProblems","AnyTransplants"), 
      "PremiumPrice")
```
```{r fig.align='center'}
# check correlation between categoric variable and target variable
ggduo(insurance_clean, 
      c("AnyChronicDiseases","KnownAllergies","HistoryOfCancerInFamily"), 
      "PremiumPrice")
```
<br>
From the correlation check that has been done, we must pay attention to a few things, such as:

- Correlation between numerical predictors and target variable: the correlation between `Age`, `NumberOfMajorSurgeries`, `BMI` with `PremiumPrice` were statistically significant
- There is a correlation between `Age` and `NumberOfMajorSurgeries`, but we can ignore it for now as we can check it later during multicollinearity-checking
- Correlation between categorical predictors and target variable (from boxplot): there are variables whose distributions are not much different for each level (or it seems that these categorical predictors -such as `Diabetes`, `KnownAllergies` and `BloodPressureProblems`- have no correlation and no effect to the target), but we can ignore them for now as we can check them later in the models

### 8. Train-Test Splitting

Divide our dataset into train set and test set respectively with a ratio of 80:20.

```{r warning=FALSE}
# train-test splitting
RNGkind(sample.kind = "Rounding")
set.seed(100)

insample <- sample(nrow(insurance_clean), nrow(insurance_clean)*0.8)
insurance_train <- insurance_clean[insample,]
insurance_test <- insurance_clean[-insample,]
```

### 9. Model Fitting

In this section, we will use the lm() function to create five models for comparison:

1. model_none: model without predictors
2. model_all: model with all predictors
3. model_backward: the model generated from backward stepwise regression process
4. model_forward: the model generated from forward stepwise regression process
5. model_both: the model generated from forward-backward stepwise regression process

##### 9.1 Without Predictor

Create a model without using any predictor. In other words, the coefficient is only an intercept.

```{r}
# model without any predictor
model_none <- lm(PremiumPrice ~ 1, data = insurance_train)
summary(model_none)
```

##### 9.2 All Predictors

Create a model with all predictors. 

```{r}
# model with all predictors
model_all <- lm(PremiumPrice ~ ., data = insurance_train)
summary(model_all)
```

##### 9.3 Backward Stepwise Regression

Create a model with backward stepwise regression process 

```{r}
# model with backward stepwise regression process 
model_backward <- step(object = model_all, direction = "backward", trace = F)
summary(model_backward)
```

##### 9.4 Forward Stepwise Regression

Create a model with forward stepwise regression process 

```{r}
# model with forward stepwise regression process 
model_forward <- step(object = model_none, 
                      direction = "forward", 
                      scope = list(upper = model_all), 
                      trace = F)
summary(model_forward)
```
##### 9.5 Forward-Backward Stepwise Regression

Create a model with forward stepwise regression process 

```{r}
# model with forward-backward stepwise regression process 
model_both <- step(object = model_none, 
                   direction = "both", 
                   scope = list(upper = model_all), 
                   trace = F)
summary(model_both)
```
### 10. Model Performance on Train Set

Compare the performance of the five models that have been generated previously. Look at their Multiple/Adjusted R-squared and RMSE values.

```{r}
# model performance comparison (based on train set)
model_comparison1 <- compare_performance(model_none, 
                                         model_all, 
                                         model_backward, 
                                         model_forward, 
                                         model_both)
as.data.frame(model_comparison1) %>% 
  select("Name","Model","AIC","R2","R2_adjusted","RMSE")
```

### 11. Prediction on Unseen Data

Use all five models to predict `PremiumPrice`, where the predictor values are wrapped in the test set.

##### 11.1 Based on model_none

```{r}
# predict based on model_none
predict_model_none <- predict(object = model_none, newdata = insurance_test)
```

##### 11.2 Based on model_all

```{r}
# predict based on model_all
predict_model_all <- predict(object = model_all, newdata = insurance_test)
```

##### 11.3 Based on model_backward

```{r}
# predict based on model_backward
predict_model_backward <- predict(object = model_backward, newdata = insurance_test)
```

##### 11.4 Based on model_forward

```{r}
# predict based on model_forward
predict_model_forward <- predict(object = model_forward, newdata = insurance_test)
```

##### 11.5 Based on model_both

```{r}
# predict based on model_both
predict_model_both <- predict(object = model_both, newdata = insurance_test)
```

### 12. Model Performance on Test Set

Let's check the RMSE values of models on testing data.

```{r}
# model performance comparison (based on test set)
Name <- c("model_none", "model_all", "model_backward", "model_forward", "model_both")
rmse_model_none <- RMSE(y_pred = predict_model_none, y_true = insurance_test$PremiumPrice)
rmse_model_all <- RMSE(y_pred = predict_model_all, y_true = insurance_test$PremiumPrice)
rmse_model_backward <- RMSE(y_pred = predict_model_backward, y_true = insurance_test$PremiumPrice)
rmse_model_forward <- RMSE(y_pred = predict_model_forward, y_true = insurance_test$PremiumPrice)
rmse_model_both <- RMSE(y_pred = predict_model_both, y_true = insurance_test$PremiumPrice)
RMSE <- c(rmse_model_none, rmse_model_all, rmse_model_backward, rmse_model_forward, rmse_model_both)
data.frame(Name, RMSE)
```

```{r}
# data distribution (as a reference only)

# data range of target variable
range(insurance_clean$PremiumPrice)
```


```{r}
# data distribution (as a reference only)

# standard deviation of target variable
sd(insurance_clean$PremiumPrice)
```

### 13. Model Selection

Based on the results above, the following insights can be obtained:

ðŸ’­ Best Model: **model_backward**

â“ Why: 

The reasons are:

- Based on model performance on training set, `model_backward`, `model_forward`, and `model_both` have the same values in all metrics. They have the smallest AIC, although their Adjusted R-squared values are slightly smaller and their RMSEs are slightly larger than the rest. They also have the same predictors, intercept, and coefficients. 
- Based on model performance on testing set, `model_backward`, `model_forward`, and `model_both` also have the same values in RMSE. They have the smallest RMSEs if we compare them to the other models. 
- Basically, we're going to focus more on the model's ability to predict new-unseen data than the historical data we've used in training. So, in this case, we will pay attention to the model performance on testing set, where `model_backward`, `model_forward`, `model_both` have the smallest RMSE values. Their Adjusted R-Squared values (based on the model performance on training set) are also slightly smaller than the rest of the models, so it's not a problem. Because all values in `model_backward`, `model_forward`, `model_both` are the same, we can choose one of these models. In this case, I choose `model_backward`. 
- In `model_backward`, all predictors were included in the model except `KnownAllergies` and `BloodPressureProblems`. This has become our concern at the beginning - when we do a correlation test between the categorical predictor variables and the target, the `PremiumPrice` distribution does not look too different for each categorical level of those two variables (it seems that these categorical predictors have no correlation and no effect to the target).
- The RMSEs from the model performance on training set are mostly smaller than in those on testing set, indicating that the models are bad at predicting new data. The RMSEs are also quite large when compared to the original data distribution (standard deviation around 6248). There is still room for improvement.

But before we tune the `model_backward`, let's check for the assumptions first.

### 14. Model Assumptions

##### 14.1 Linearity

Using linearity hypothesis test:

- H0: there is no significant correlation
- H1: there is significant correlation

Conclusion: We have already tested the correlation between each numerical predictor variables and the target variable - all the predictor variables used in `model_backward` are significantly correlated with the target variable. Assumption fulfilled.

##### 14.2 Normality of Errors

Using Shapiro-Wilk hypothesis test:

- H0: errors are normally-distributed
- H1: errors are not normally-distributed

```{r}
# check normality
check_normality(model_backward)
```

Conclusion: p-value < 0.05, then reject H0. Errors are not normally distributed. Assumption is not fulfilled.

##### 14.3 Homoscedasticity of Errors

Using Breusch-Pagan hypothesis test:

- H0: homoscedasticity is present (the errors are distributed with equal variance)
- H1: heteroscedasticity is present (the errors are not distributed with equal variance)

```{r}
# check heteroscedasticity
check_heteroscedasticity(model_backward)
```
Conclusion: p-value > 0.05, then there is not enough evidence to reject H0. Errors are distributed with equal variance (homoscedasticity is present). Assumption fulfilled.

##### 14.4 No Multicollinearity

Check VIF (Variance Inflation Factor) value for each predictor variable with the following conditions:

- VIF value > 10: multicollinearity occurs in the model
- VIF value < 10: there is no multicollinearity in the model

```{r}
# check multicollinearity
data.frame(check_collinearity(model_backward))
```
Conclusion: all VIF values < 10, then there is no multicollinearity in the model. Assumption fulfilled. 

##### 14.5 Recap

Based on the assumption tests that have been done, which assumptions have been met?

- [x] The correlation between target variable and each predictor variable must be linear
- [ ] Errors are normally-distributed
- [x] Errors are distributed with equal variance (homoscedasticity is present)
- [x] There is no multicollinearity in the model

### 15. Additional: Model Tuning

Model tuning is the process of improving performance in various ways, such as feature engineering, removing outliers, transforming, etc. The goal is to minimize the error or fulfill certain assumptions.

##### 15.1 Target Transformation

Target transformation is done in order to make data become more suitable for normal distribution. In addition, most data scientists believe that they get more accurate results when they perform target transformation. This time, we will use the square-root transformation.

```{r}
# target transformation
insurance_train_tune <- insurance_train %>% 
  mutate(sqrt_PremiumPrice = sqrt(PremiumPrice)) %>% 
  select(-PremiumPrice)
```

See below for the evidence that the sqrt function can remove outliers.

```{r, figures-side, fig.show="hold", out.width="50%"}
par(mar = c(2, 3, 2, 2))

# before transformation
boxplot(insurance_train$PremiumPrice,
        main = "Distribution of Premium Price (Before Transformation)")

# after transformation
boxplot(insurance_train_tune$sqrt_PremiumPrice,
        main = "Distribution of Premium Price (After Transformation)")
```

##### 15.2 Re-modeling

Create five new models using the transformed data. The five models have the following details:

1. model_none_tune: model without predictors
2. model_all_tune: model with all predictors
3. model_backward_tune: the model generated from backward stepwise regression process
4. model_forward_tune: the model generated from forward stepwise regression process
5. model_both_tune: the model generated from forward-backward stepwise regression process

```{r}
# re-modeling
model_none_tune <- lm(sqrt_PremiumPrice ~ 1, data = insurance_train_tune)
model_all_tune <- lm(sqrt_PremiumPrice ~ ., data = insurance_train_tune)
model_backward_tune <- step(object = model_all_tune, direction = "backward", trace = F)
model_forward_tune <- step(object = model_none_tune, direction = "forward", scope = list(upper = model_all_tune), trace = F)
model_both_tune <- step(object = model_none_tune, direction = "both", scope = list(upper = model_all_tune), trace = F)
```

##### 15.3 Prediction using New Models

Make predictions using five new models.

```{r}
# prediction using training set predictors
predict_model_none_tune_train <- (model_none_tune$fitted.values)^2
predict_model_all_tune_train <- (model_all_tune$fitted.values)^2
predict_model_backward_tune_train <- (model_backward_tune$fitted.values)^2
predict_model_forward_tune_train <- (model_forward_tune$fitted.values)^2
predict_model_both_tune_train <- (model_both_tune$fitted.values)^2
```

```{r}
# prediction using testing set predictors
predict_model_none_tune_test <- (predict(object = model_none_tune, newdata = insurance_test))^2
predict_model_all_tune_test <- (predict(object = model_all_tune, newdata = insurance_test))^2
predict_model_backward_tune_test <- (predict(object = model_backward_tune, newdata = insurance_test))^2
predict_model_forward_tune_test <- (predict(object = model_forward_tune, newdata = insurance_test))^2
predict_model_both_tune_test <- (predict(object = model_both_tune, newdata = insurance_test))^2
```

##### 15.4 New Models' Performance

Calculate the RMSE of Models' Predictions.

```{r}
# RMSE on training set
rmse_none_tune_train <- RMSE(y_pred = predict_model_none_tune_train, y_true = insurance_train$PremiumPrice)
rmse_all_tune_train <- RMSE(y_pred = predict_model_all_tune_train, y_true = insurance_train$PremiumPrice)
rmse_backward_tune_train <- RMSE(y_pred = predict_model_backward_tune_train, y_true = insurance_train$PremiumPrice)
rmse_forward_tune_train <- RMSE(y_pred = predict_model_forward_tune_train, y_true = insurance_train$PremiumPrice)
rmse_both_tune_train <- RMSE(y_pred = predict_model_both_tune_train, y_true = insurance_train$PremiumPrice)
```

```{r}
# RMSE on testing set
rmse_none_tune_test <- RMSE(y_pred = predict_model_none_tune_test, y_true = insurance_test$PremiumPrice)
rmse_all_tune_test <- RMSE(y_pred = predict_model_all_tune_test, y_true = insurance_test$PremiumPrice)
rmse_backward_tune_test <- RMSE(y_pred = predict_model_backward_tune_test, y_true = insurance_test$PremiumPrice)
rmse_forward_tune_test <- RMSE(y_pred = predict_model_forward_tune_test, y_true = insurance_test$PremiumPrice)
rmse_both_tune_test <- RMSE(y_pred = predict_model_both_tune_test, y_true = insurance_test$PremiumPrice)
```

```{r}
# dataframe containing rmse
model <- c("model_none_tune", "model_all_tune", "model_backward_tune", "model_forward_tune", "model_both_tune")
rmse_train <- c(rmse_none_tune_train, rmse_all_tune_train, rmse_backward_tune_train, rmse_forward_tune_train, rmse_both_tune_train)
rmse_test <- c(rmse_none_tune_test, rmse_all_tune_test, rmse_backward_tune_test, rmse_forward_tune_test, rmse_both_tune_test)
data.frame(model, rmse_train, rmse_test)
```

Based on the table above, `model_backward_tune` can be chosen as the best model because it has the smallest RMSE value (rmse_test). However, it seems that the target transformation cannot reduce the RMSE. Still, let's see if the tuning model can satisfy all the linear regression assumptions.

##### 15.5 New Models' Assumptions

```{r}
# check normality
check_normality(model_backward_tune)
```

```{r}
# check heteroscedasticity
check_heteroscedasticity(model_backward_tune)
```

```{r}
# check multicollinearity
data.frame(check_collinearity(model_backward_tune))
```
Conclusion on assumption test:

- [ ] Errors are normally-distributed
- [x] Errors are distributed with equal variance (homoscedasticity is present)
- [x] There is no multicollinearity in the model

##### 15.6 Conclusion on Tuned Model

It seems that the tuned model still can't improve the performance of our model (the RMSE actually gets bigger and there are still assumption that is not fulfilled). I've also tried log transformation on the target column, but the result is still the same.
Therefore, because the untuned model gives a smaller RMSE value, it is better to use the untuned model (`model_backward`) for interpretation.

### 16. Conclusion and Interpretation


1. Best model: `model_backward` with summary as follows.

```{r}
summary(model_backward)
```
and its formula:
$$PremiumPrice = 5640.40 + 338.96 * Age - 577.72 * Diabetes1 (Diabetes: Yes) +$$
$$8305.87 * AnyTransplants1 (AnyTransplants: Yes) +$$
$$2682.18 *
    AnyChronicDiseases1 (AnyChronicDiseases: Yes) +$$
$$ 2567.94 * HistoryOfCancerInFamily1 (HistoryOfCancerInFamily: Yes) -$$
$$816.13 * NumberOfMajorSurgeries + 151.72 * BMI$$

2. Model Interpretation:

  - The older a person is, the higher the premium price (because Age has positive coefficient), assuming the values of other predictors are constant.
  - The greater the BMI value, the higher the premium price (because BMI has positive coefficient), assuming the values of other predictors are constant.
  - The greater the number of major surgeries that have been performed, the lower the premium price (because NumberofMajorSurgeries has the negative coefficient), assuming the values of other predictors are constant.
  - A person who is a diabetic will have cheaper charges, which is 577.72 Indian rupees cheaper than to those who are not diabetic, assuming the values of other predictors are constant.
  - A person who has had an organ transplant will have more expensive charges, which is 8305.87 Indian rupees more expensive than to those who have not had an organ transplant, assuming the values of other predictors are constant.
  - A person who has a chronic disease will have more expensive charges, which is 2682.18 Indian rupees more expensive than to those who do not have a chronic disease, assuming the values of other predictors are constant.
  - A person who has a blood relation to a cancer patient has more expensive charges, which is 2567.94 Indian rupees more expensive than to those who don't have a blood relation to a cancer patient, assuming the value of other predictors is constant.
  - Variables `AnyTransplants`, `AnyChronicDiseases`, `HistoryOfCancerInFamily` seem to contribute greatly in determining the premium price because they have large coefficient values.
  - The predictors used in model can explain the variation of the premium price by 65.53%, where the remaining variation is explained by other factors that are not used in the modeling.


3. Concerns:

  - The Adjusted R-Square generated by `model_backward` is still relatively small. Hence, there is a possibility that some other variables out there can significantly affect the medical insurance premiums. In addition, the RMSE value is still relatively large, so it is very recommended to add other variables that can improve prediction accuracy.
  - `Diabetes` and `NumberOfMajorSurgeries` variables have negative coefficients, in which this does not match with our intuition and our logic. This situation can be studied further in the future.
  - `model_backward` returns errors that are not normally distributed - it does not meet the linear regression assumption. Actually, this assumption is optional as the Ordinary Least Squares (OLS) method doesn't require a normally-distributed errors to produce unbiased estimates with minimum variance. However, the non-fulfillment of this assumption can make the results of statistical hypothesis testing (parameter significance test) and the calculation of confidence intervals become misleading. Therefore, this situation can be overcome by using other methods that may also increase the accuracy of predictions, e.g. nonparametric regression.



